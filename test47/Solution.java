package test47;
/**
 * 把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。
 * 例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。
 * 基本思路
 * 根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果（1除外）。因此我们可以创建一个集合，里面的数字是排好序的丑数，每一个丑数都是前面的丑数乘以2、3或者5得到的。
 * 
 * 这种思路的关键是在于怎么保证集合里面的丑数是排好序的。
 * 假设集合中已经有若干个丑数排好序后放在集合中，并且把已有最大的丑数记做M，我们接下来分析如何生成下一个丑数。
 * 该丑数肯定是前面某一个丑数乘以2、3或者5的结果，
 * 我们首先考虑把已有的丑数乘以2、3和5，然后通过比较三个数的大小，找出三个数中最小的丑数存入集合。
 * 为了避免重复，如果最小的丑数等于乘以2的结果，i2++；如果最小的丑数等于乘以3的结果，i3++;如果最小的丑数等于乘以5的结果，i5++（i2、i3和i5是集合的索引且初值为0，首先集合存入1）。
 * 这样得到的丑数在集合中是按照从小到大排序的。
 * @author 54060
 *
 */
public class Solution {
	public int GetUglyNumber_Solution(int N) {
	    if (N <= 6)
	        return N;
	    int i2 = 0, i3 = 0, i5 = 0;
	    int[] dp = new int[N];
	    dp[0] = 1;
	    for (int i = 1; i < N; i++) {
	        int next2 = dp[i2] * 2, next3 = dp[i3] * 3, next5 = dp[i5] * 5;
	        dp[i] = Math.min(next2, Math.min(next3, next5));  //把已有的丑数乘以2、3和5，然后通过比较三个数的大小，找出三个树中最小的丑数存入集合
	        if(dp[i] == next2)
	            i2++;
	        if(dp[i] == next3)
	            i3++;
	        if(dp[i] == next5)
	            i5++;
	    }
	    return dp[N - 1];
	}
}
